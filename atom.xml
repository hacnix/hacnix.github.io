<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>二哈的博客</title>
  <icon>https://www.gravatar.com/avatar/ad3df9bd4d178f1c96b0d6984e25ca1a</icon>
  <subtitle>这个家伙很懒，什么都没有留下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hacnix.github.io/"/>
  <updated>2019-07-15T11:10:00.302Z</updated>
  <id>https://hacnix.github.io/</id>
  
  <author>
    <name>二哈的博客</name>
    <email>wkxm@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K近邻算法（KNN）</title>
    <link href="https://hacnix.github.io/2019/07/15/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%EF%BC%88KNN%EF%BC%89/"/>
    <id>https://hacnix.github.io/2019/07/15/K近邻算法（KNN）/</id>
    <published>2019-07-15T10:36:26.000Z</published>
    <updated>2019-07-15T11:10:00.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/15/5d2c5eebdc15887548.jpg" alt="03087bf40ad162d95867202e15dfa9ec8a13cd73.jpg"></p><a id="more"></a><h1 id="KNN算法介绍"><a href="#KNN算法介绍" class="headerlink" title="KNN算法介绍"></a>KNN算法介绍</h1><p>K邻近算法，或者说K最近邻(kNN，k-NearestNeighbor)分类算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。</p><p>kNN算法的核心思想是如果一个样本在特征空间中的k个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 kNN方法在类别决策时，只与极少量的相邻样本有关。由于kNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，kNN方法较其他方法更为适合。</p><p>图中，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。</p><p><img src="https://i.loli.net/2019/07/15/5d2c5d321656581275.jpg" alt="bf096b63f6246b60f20ccd5aebf81a4c510fa29a.jpg"></p><h1 id="k近邻法的三要素"><a href="#k近邻法的三要素" class="headerlink" title="k近邻法的三要素"></a>k近邻法的三要素</h1><p>距离度量、k值的选择及分类决策规则是k近邻法的三个基本要素。根据选择的距离度量（如曼哈顿距离或欧氏距离），可计算测试实例与训练集中的每个实例点的距离，根据k值选择k个最近邻点，最后根据分类决策规则将测试实例分类。</p><h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p>距离的定义为</p><p><img src="https://i.loli.net/2019/07/15/5d2c5aa8e8bf069658.png" alt="20180731023052309.png"></p><p>当 p = 1 时为曼哈顿距离；</p><p>当 p = 2 时为欧氏距离；</p><p>当 p为无穷时，它是各个坐标距离的最大值；</p><h2 id="K值"><a href="#K值" class="headerlink" title="K值"></a>K值</h2><p>当k = 1的时候就是表示最近邻算法，即对于一个新输入的实例，它的所属类别就是和训练样本中和它最近的实例类别。当k过大，会导致近似误差大，较远的实例都会对最终的判定起作用；k过小，估计误差大，对近邻的点敏感。所以一般在没有先验知识下都是采用交叉验证的方式选取。</p><h2 id="分类决策"><a href="#分类决策" class="headerlink" title="分类决策"></a>分类决策</h2><p>k近邻法中的分类决策规则往往是多数表决，即由输入实例的k个邻近的训练实例中的多数类，决定输入实例的类。</p><h1 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h1><p>sklearn中的函数（基于python）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X=[[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]] <span class="comment">#建一个List</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>] <span class="comment">#建一个List</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor <span class="comment">#导入K近邻回归模块</span></span><br><span class="line">neigh=KNeighborsRegressor(n_neighbors=<span class="number">2</span>) <span class="comment">#近邻参数设置成2个相邻</span></span><br><span class="line">neigh.fit(X, y) <span class="comment">#使用X作为训练数据，y作为目标值</span></span><br><span class="line">print(neigh.predict([[<span class="number">1.5</span>]])) <span class="comment">#给提供的数据预测对应的标签，当x=1.5的时候y应该是多少</span></span><br><span class="line"><span class="comment">#最终输出当x=1.5的时候y=0.5</span></span><br></pre></td></tr></table></figure></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>简单，易于理解，易于实现，无需估计参数，无需训练；</li><li>适合对稀有事件进行分类；</li><li>特别适合于多分类问题(multi-modal,对象具有多个类别标签)， kNN比SVM的表现要好。<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2></li><li>该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。 该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。</li><li>该方法的另一个不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最近邻点。</li><li>可理解性差，无法给出像决策树那样的规则。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://baike.baidu.com/item/%E9%82%BB%E8%BF%91%E7%AE%97%E6%B3%95/1151153?fr=aladdin" target="_blank" rel="noopener">百度百科，https://baike.baidu.com/item/%E9%82%BB%E8%BF%91%E7%AE%97%E6%B3%95/1151153</a></p></li><li><p><a href="https://blog.csdn.net/eeeee123456/article/details/79927128" target="_blank" rel="noopener">机器学习（二）：k近邻法（kNN）https://blog.csdn.net/eeeee123456/article/details/79927128</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42180810/article/details/81294957" target="_blank" rel="noopener">机器学习之K近邻法（KNN）https://blog.csdn.net/weixin_42180810/article/details/81294957</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/15/5d2c5eebdc15887548.jpg&quot; alt=&quot;03087bf40ad162d95867202e15dfa9ec8a13cd73.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://hacnix.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://hacnix.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="KNN" scheme="https://hacnix.github.io/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加Gitalk评论系统</title>
    <link href="https://hacnix.github.io/2019/07/11/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hacnix.github.io/2019/07/11/Hexo博客添加Gitalk评论系统/</id>
    <published>2019-07-11T01:23:04.000Z</published>
    <updated>2019-07-11T01:34:06.203Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/11/5d2691595f62f41376.jpg" alt="5d2691595f62f41376.jpg.jpg"><br><a id="more"></a></p><blockquote><p>本文转载自<a href="https://www.itfanr.cc/2019/04/30/hexo-add-gitalk-comment/" target="_blank" rel="noopener">IT范</a></p></blockquote><p>经朋友的提醒，我发现我的博客中的评论插件Gitment已经不能正常使用了。简单的分析了一下：发布评论内容后 Gitment 区域就会一直显示 Logging in… 的加载错误信息，查看网络请求，发现是Gitment插件中使用的一个域名 <a href="https://gh-oauth.imsun.net" target="_blank" rel="noopener">https://gh-oauth.imsun.net</a> 的Https证书已经过期了。</p><p>查看了一下该域名的证书，发现早在 2018年9月14日 就到期了，哎，我说为什么我的博客一直没有人评论呢，原来是这个原因。</p><p>问题是找到了，但博客评论的功能可不能去掉，毕竟这是一个很好的交流问题的地方。</p><p>在网上搜索了一下，发现了一款名为 Gitalk 的评论插件，和 Gitment 功能实现差不多。看了看github中的issues信息，发现 Gitalk 的活跃度还是很高的。</p><p>因为我用的是 Hexo 的 Next 主题，去 Next 的官网中找了一下文档，发现并没有直接集成 Gitalk 评论插件。那看来只能自己改造了。</p><p>想想当时我加入 Gitment 评论插件时，Next主题已经集成好了，所以只要打开并添加好自己的 GitHub token 信息之后，就能正常使用了。而 Gitment 和 Gitalk 都是评论插件，所以只要按照 Gitment的方式来修改即可，也是很简单的。</p><p>废话不多说，Gitalk 用起来。</p><p>提示：建议和我之前的文章 Hexo博客添加Gitment评论系统 | IT范儿 一起食用，体验更好哟！！！</p><h1 id="禁用Gitment"><a href="#禁用Gitment" class="headerlink" title="禁用Gitment"></a>禁用Gitment</h1><p>将 themes/next/_config.yml 文件中的 gitment: enable:true 改为 false。关闭 Gitment 的评论插件。<br>使用Gitalk</p><p>先简单过一下 Gitalk 的文档：gitalk/gitalk: Gitalk is a modern comment component based on Github Issue and Preact.</p><p>Gitalk 的使用非常简单：</p><pre><code>导入链接添加占位标签初始化插件自定义设置</code></pre><h1 id="添加初始化代码"><a href="#添加初始化代码" class="headerlink" title="添加初始化代码"></a>添加初始化代码</h1><p>在 Next 主题中，第三方的插件都放在了 _third-party 目录下。</p><p>在 themes/next/layout/third-party/comments 中新建 gitalk.swig:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">          clientID: <span class="string">'&#123;&#123; theme.gitalk.ClientID &#125;&#125;'</span>,</span><br><span class="line">          clientSecret: <span class="string">'&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;'</span>,</span><br><span class="line">          repo: <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">          owner: <span class="string">'&#123;&#123; theme.gitalk.owner &#125;&#125;'</span>,</span><br><span class="line">          admin: [<span class="string">'&#123;&#123; theme.gitalk.adminUser &#125;&#125;'</span>],</span><br><span class="line">          id:<span class="string">'&#123;&#123; theme.gitalk.IdPrefix || gitalk &#125;&#125;_&#123;&#123; date(page.date, "YYYYMMDDHHmmss") &#125;&#125;'</span>,</span><br><span class="line">          labels: <span class="string">'&#123;&#123; theme.gitalk.labels &#125;&#125;'</span>,</span><br><span class="line">          perPage: &#123;&#123; theme.gitalk.perPage &#125;&#125;,</span><br><span class="line">          pagerDirection: <span class="string">'&#123;&#123; theme.gitalk.pagerDirection &#125;&#125;'</span>,</span><br><span class="line">          createIssueManually: &#123;&#123; theme.gitalk.createIssueManually &#125;&#125;,</span><br><span class="line">          distractionFreeMode: &#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(<span class="string">'gitalk-container'</span>)           </span><br><span class="line">       &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="载入插件"><a href="#载入插件" class="headerlink" title="载入插件"></a>载入插件</h1><p>在 themes/next/layout/third-party/comments 中找到 index.swig 文件，新增 gitalk.swig:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include <span class="string">'gitalk.swig'</span> %&#125;</span><br></pre></td></tr></table></figure></p><h1 id="添加占位标签"><a href="#添加占位标签" class="headerlink" title="添加占位标签"></a>添加占位标签</h1><p>在 themes/next/layout/_partials 中，找到 comments.swig 文件，这里面是所有支持的评论插件的占位符所放的位置。就拿之前使用的 gitment 来说，可以看到如下的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"comments"</span> id=<span class="string">"comments"</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> theme.gitment.lazy %&#125;</span><br><span class="line">      &lt;div onclick=<span class="string">"showGitment()"</span> id=<span class="string">"gitment-display-button"</span>&gt;&#123;&#123; __(<span class="string">'gitmentbutton'</span>) &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div id="gitment-container" style="display:none"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">      &lt;div id=<span class="string">"gitment-container"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中的每一个<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">elseif</span> theme.xxxxx.enable %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>部分，表示的就是一个评论插件功能。</p><p>将上面代码段精简一下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comments"</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitment-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以发现：<div id="gitment-container"></div> 就是评论框的占位标签了。</p><p>那么依葫芦画瓢，我们将上面的代码稍微修改成 gitealk 的占位标签：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comments"</span> <span class="attr">id</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后将其加入到任意两个<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">elseif</span> theme.xxxxx.enable %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>代码段之间即可。</p><h1 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h1><p>打开 Next 主题的配置文件 themes/next/_config.yml ，加上如下内容：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ClientID:</span> <span class="string">xxxxxx</span></span><br><span class="line"><span class="attr">  ClientSecret:</span> <span class="string">xxxxxxxxxxxx</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">gitalk</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">xxxxx</span></span><br><span class="line"><span class="attr">  adminUser:</span> <span class="string">xxxxx</span></span><br><span class="line"><span class="attr">  IdPrefix:</span> <span class="string">gitalk</span></span><br><span class="line"><span class="attr">  labels:</span> <span class="string">gitalk</span></span><br><span class="line"><span class="attr">  perPage:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  pagerDirection:</span> <span class="string">last</span></span><br><span class="line"><span class="attr">  createIssueManually:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>其中：repo 表示将 issues 提交到哪个仓库。 IdPrefix 是我自定义添加的参数，表示ID 值的前缀。其他项可直接参考官方的文档来进行修改：gitalk/readme-cn.md at master · gitalk/gitalk<br>问题解决<br>i.concat(…).join is not a function</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>执行 hexo s -g 预览博客，发现评论部分报错：</p><blockquote><p>Error: i.concat(…).join is not a function</p></blockquote><p>这个问题是 labels 部分的问题，通过如下方式处理，将 labels 修改为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label<span class="variable">s:</span> <span class="string">'&#123;&#123; theme.gitalk.labels &#125;&#125;'</span>.<span class="keyword">split</span>(<span class="string">','</span>).<span class="built_in">filter</span>(<span class="keyword">l</span> =&gt; <span class="keyword">l</span>,</span><br></pre></td></tr></table></figure><p>更改为 Gitalk 之后，发现之前使用 Gitment 已经创建了 issues 的文章却提示 未找到相关的 Issues 进行评论 :</p><p>原因是：</p><p>Gitalk 评论插件是通过 issues 的 labels 来标识一篇文章的。如果 labels 中存在相应文章的 label 标签，那就说明该文章已经初始化过了。</p><p>比如 我一篇文章设置的 ID 为 itfanr_blog_20190426225702 ，默认的 labels 为 gitalk，那么相应的issues如下：</p><p>这两个label一起来标识一篇文章。</p><p>因为上面我将ID值的格式进行了修改：</p><p>原来:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>: 'itfanr_blog_&#123;&#123; <span class="built_in">date</span>(page.<span class="built_in">date</span>, <span class="string">"YYYYMMDDhhmmss"</span>) &#125;&#125;',</span><br></pre></td></tr></table></figure></p><p>现在：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>:'&#123;&#123; theme.gitalk.IdPrefix || gitalk &#125;&#125;_&#123;&#123; <span class="built_in">date</span>(page.<span class="built_in">date</span>, <span class="string">"YYYYMMDDHHmmss"</span>) &#125;&#125;',</span><br></pre></td></tr></table></figure></p><p>其中的时间戳格式进行了更改，也就导致了 labels 不匹配而找不到了。</p><p>由于暂时没有找到如何批量更新 labels 的方法，而一个一个的手动更改又太麻烦了。所以我就删除原来的 issues，重新进行创建。此时，我发现 Gitalk 一个好用的地方是，当将配置项 createIssueManually 设置为 false 时，如果发现是管理员浏览文章，会自动为该文章初始化评论功能，非常方便。</p><p>另外一个主要的原因是：这几个月我的博客一直没有评论，所以好多都是空的 issues，删除重建也就没有什么犹豫了。<br>关于文章ID</p><p>这里需要说明的是 ID 这一项。</p><p>依照gitalk文档中的解释，该值表示当前页面的唯一id，且长度不能超过50：</p><blockquote><p>The unique id of the page. Length must less than 50.</p></blockquote><p>所以，我这里设置为了 前缀+文章create时间戳的方式来实现唯一性。</p><p>通过在配置文件中指定 IdPrefix 来表示前缀，默认值为 gitalk。</p><p>如果你不想用时间戳的方式，也可以使用文章链接的MD5值来实现唯一ID，方法如下：</p><p>在上面 themes/next/layout/third-party/comments/gitalk.swig 中添加对 md5.js的引用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>修改ID部分为：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">id:</span> <span class="string">md5(location.pathname),</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/11/5d2691595f62f41376.jpg&quot; alt=&quot;5d2691595f62f41376.jpg.jpg&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://hacnix.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hacnix.github.io/tags/hexo/"/>
    
      <category term="Gitalk" scheme="https://hacnix.github.io/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>Git使用--分支管理</title>
    <link href="https://hacnix.github.io/2019/07/10/Git%E4%BD%BF%E7%94%A8-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>https://hacnix.github.io/2019/07/10/Git使用-分支管理/</id>
    <published>2019-07-10T07:30:15.000Z</published>
    <updated>2019-07-10T08:28:38.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/10/5d25a1a1ae1f338861.png" alt="ep3.png"><br><a id="more"></a></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文转载自<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">廖雪峰的官方网站</a></p><p>大家多多支持廖雪峰老师。</p><h1 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h1><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://i.loli.net/2019/07/10/5d2596eaf105572610.png" alt="5d2596eaf105572610.png.png"></p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p><p><img src="https://i.loli.net/2019/07/10/5d25979068c6654615.png" alt="5d25979068c6654615.png.png"></p><p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="https://i.loli.net/2019/07/10/5d259880c00b081707.png" alt="5d259880c00b081707.png.png"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><p><img src="https://i.loli.net/2019/07/10/5d2598aa6d98570215.png" alt="5d2598aa6d98570215.png.png"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p><a href="https://i.loli.net/2019/07/10/5d2598e959be257037.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/10/5d2598e959be257037.png" alt="5d2598e959be257037.png.png"></a></p><p>首先，我们创建dev分支，然后切换到dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p><p>然后，用git branch命令查看当前分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p><p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p><p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p><p>Creating a new branch is quick.</p><p>然后提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br><span class="line">[dev b17d20e] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>现在，dev分支的工作完成，我们就可以切换回master分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure></p><p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p><p>现在，我们把dev分支的工作成果合并到master分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure></p><p>删除后，查看branch，就只剩下master分支了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>查看分支：git branch</p><p>创建分支：git branch <name></name></p><p>切换分支：git checkout <name></name></p><p>创建+切换分支：git checkout -b <name></name></p><p>合并某分支到当前分支：git merge <name></name></p><p>删除分支：git branch -d <name></name></p><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的feature1分支，继续我们的新分支开发：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure></p><p>修改readme.txt最后一行，改为：</p><p>Creating a new branch is quick AND simple.</p><p>在feature1分支上提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p><p>切换到master分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure></p><p>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</p><p>在master分支上把readme.txt文件的最后一行改为：</p><p>Creating a new branch is quick &amp; simple.</p><p>提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></p><p>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：</p><p><img src="https://i.loli.net/2019/07/10/5d259aabb22f215496.png" alt="5d259aabb22f215496.png.png"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure></p><p>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure></p><p>我们可以直接查看readme.txt的内容：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</p><p>Creating a new branch is quick and simple.</p><p>再提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure></p><p>现在，master分支和feature1分支变成了下图所示：</p><p><img src="https://i.loli.net/2019/07/10/5d259af8e3f7b53726.png" alt="5d259af8e3f7b53726.png.png"></p><p>用带参数的git log也可以看到分支的合并情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch <span class="built_in">test</span></span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure></p><p>最后，删除feature1分支：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d feature1</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>feature1 (was <span class="number">14096</span><span class="built_in">d0</span>).</span><br></pre></td></tr></table></figure></p><p>工作完成。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用git log –graph命令可以看到分支合并图。</p><h1 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h1><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下–no-ff方式的git merge：</p><p>首先，仍然创建并切换dev分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p><p>修改readme.txt文件，并提交一个新的commit：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"add merge"</span></span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>现在，我们切换回master：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure></p><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p><p>合并后，我们用git log看看分支历史：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>可以看到，不使用Fast forward模式，merge后就像这样：</p><p><img src="https://i.loli.net/2019/07/10/5d259d2c5b89254296.png" alt="5d259d2c5b89254296.png.png"></p><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/10/5d25a1a1ae1f338861.png&quot; alt=&quot;ep3.png&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://hacnix.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://hacnix.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加Disqus评论</title>
    <link href="https://hacnix.github.io/2019/07/10/Hexo%E6%B7%BB%E5%8A%A0Disqus%E8%AF%84%E8%AE%BA/"/>
    <id>https://hacnix.github.io/2019/07/10/Hexo添加Disqus评论/</id>
    <published>2019-07-10T05:00:34.000Z</published>
    <updated>2019-07-10T05:25:45.721Z</updated>
    
    <content type="html"><![CDATA[<p>国内的评论系统畅言需要ICP备案，网易云跟帖没用过，那天鼓捣鼓捣。</p><p><img src="https://i.loli.net/2019/07/10/5d2576cb1e3eb90595.png" alt="Disqus-comment-system-hacked.png"><a id="more"></a><br>还有人说用Valine那个评论系统。我试了一下那个系统居然要求我实名注册，让我输入真实姓名与身份证号，并且上传手持身份证的照片。</p><p>在光天化日之下居然有如此过分的要求，果断放弃。</p><p>绕了一圈发现能用的就剩下两个，gitment和Disqus。gitment显然不大众化，仅仅有程序员群体再用。</p><p>博主博客使用的是国外的Disqus评论系统,只能科学上网后使用。</p><p>我用的是NexT主题，搭配disqus还算是相当容易安装。其实hexo的插件一般都挺容易安装的。</p><h1 id="注册Disqus账号"><a href="#注册Disqus账号" class="headerlink" title="注册Disqus账号"></a>注册Disqus账号</h1><p>Disqus网址：<a href="https://disqus.com/" target="_blank" rel="noopener">https://disqus.com/</a></p><p>打开链接后，可以直接用Facebook，Twitter以及Google登录；也可以用邮箱注册后登录。</p><p>安装只需要打开注册一个Disqus账号，用谷歌账号登录就可以。</p><h1 id="新建一个Disqus应用"><a href="#新建一个Disqus应用" class="headerlink" title="新建一个Disqus应用"></a>新建一个Disqus应用</h1><p>登录后，点击首页的GET STARTED 按钮，点击图示按钮。来开始在自己网站上安装评论系统</p><p><img src="https://i.loli.net/2019/07/10/5d25736f5ec0e17802.png" alt="5863464-7d0a40ee35c0dafa.png"></p><p>剩下的按照你站点的实际情况去填就好了。</p><h1 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h1><p>在主题配置文件(_config.yml)文件中找到以下代码，<em>添加你Disqus生成的shortname填写在配置文件的shortname处</em>，英文冒号后空格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加在这里</span></span><br><span class="line"><span class="comment"># Disqus </span></span><br><span class="line">disqus:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  shortname: your-name    <span class="comment">#your name</span></span><br><span class="line">  count: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> clean</span><br><span class="line"><span class="variable">$hexo</span> g</span><br><span class="line"><span class="variable">$hexo</span> s</span><br></pre></td></tr></table></figure><p>然后打开<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>任意一篇文章拉到下面看一下，看是不是会出来评论框。</p><p>如果没有出来的话，一般是shotname填写的和Disqus官网上不一致。改正即可。注意，全程需要科学上网。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内的评论系统畅言需要ICP备案，网易云跟帖没用过，那天鼓捣鼓捣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/10/5d2576cb1e3eb90595.png&quot; alt=&quot;Disqus-comment-system-hacked.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://hacnix.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hacnix.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://hacnix.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>一条老咸鱼的RM参赛之旅</title>
    <link href="https://hacnix.github.io/2019/07/09/%E4%B8%80%E6%9D%A1%E8%80%81%E5%92%B8%E9%B1%BC%E7%9A%84RM%E5%8F%82%E8%B5%9B%E4%B9%8B%E6%97%85/"/>
    <id>https://hacnix.github.io/2019/07/09/一条老咸鱼的RM参赛之旅/</id>
    <published>2019-07-09T12:27:28.000Z</published>
    <updated>2019-07-13T11:55:39.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大多数时候，都在思考自己该走向何方。</p></blockquote><p><img src="https://i.loli.net/2019/07/09/5d24ac9342dc284698.jpg" alt="900137ef1538035970503310600.jpg"></p><a id="more"></a><p>本咸鱼大二上半年加入机器人队。刚入队时作为萌新经常不务正业。比如曾经痴迷于小车的制作，当时队里有一位“车王”，做过各种小车经验丰富，我是相当羡慕他。</p><p>这个时候任务不多，每天就是坐在自己的位置学习关于计算机视觉的一些东西。白天上课，晚上会来实验室，十点半回寝室。主要变化是周六日不能赖床了，八点前得到实验室学习，考勤很严格。这个时候除了写一些简单的视觉代码之外，各种杂活也是我负责。</p><p>临近过年的时候我被分到了RoboMaster组，做视觉。这个时候的我只听说过2017年师兄们这个比赛做的很失败，比完赛后他们没有一个人留下来。没有任何传承。当时只有三辆小步兵车，黄色玻纤板。底盘很低，移动起来缓慢，并且时常卡住子弹。</p><p>我问学长，我做视觉的任务是什么？</p><p>学长告诉我，这一年的规则里哨兵是全自动机器人，需要自主识别敌人进行打击。所以你要做识别装甲板并且自动打击的程序。</p><p>第一年什么也不懂，至于装甲板我没有概念。我觉得会是类似一个板子的东西。</p><p>2018赛季我们哨兵的进度，从机械到控制再到视觉，进度缓慢。机械组最后一周才拼装完成。我也是拼拼凑凑才完成了视觉的基本功能。</p><p>最后几天和电控调节了云台，底盘能随机运动，算是有了基本功能。但这时候哨兵云台和底盘还是分离状态，这个时候已经到了启程去北京中石油比赛的时间节点了，没有时间在实验室搞了，我们商量着到北京之后把哨兵继续进行下去。</p><p>在中石油附近的民宿内很挤，小屋子有十来个人外加步兵和哨兵。找了几跟方铝型材，把家具往一起凑了凑，方铝搭在家具上，做成了最简单的哨兵轨道，起码哨兵现在有个安身之地了。</p><p>没有时间考虑睡觉的事，吃完了在北京的第一顿饭之后返回住处，开始通宵干活。</p><p>白天也不能闲，得需要我们抬着机器人往返于备赛区和检录区、拍照区、测试区等等，进行一系列的预检录、定妆照等活动。</p><p>只要还没比赛，我们就进行着机器人的调试工作，无论白天还是黑夜。抬着机器人走在昌平街道上，觉得很重手很疼，都是由于准备的不充分忘了带推车了。只能默默羡慕其他队员住宾馆有板车。</p><p>最后一天晚上的情况依然很糟糕，但只能这样了。没有周旋的余地，也没有奇迹会发生。此时多希望在实验室的时间能充足一些。</p><p>英雄打不出去子弹卡弹，哨兵云台脱落，乱发子弹等问题预示着小组赛我们就无情的被淘汰了。</p><p>小组赛被淘汰后很难过，一年的坚持，曾经通宵的晚上都幻想着会拿到一个好的结果。人员安排的不合理、缺少传承种种原因：现实就是如此残酷，结果拍在脸上告诉你，这一年你们做的太差了。</p><p>当时恨不得把机器人砸了，自己亲手做的东西多么糟糕，只能被人吊打。</p><p>结束小组赛那天晚上丁文龙负责炒菜，买了好多白酒。很多人喝多了，说了很多。有些人直接喝哭了。大家一起撑过来的一年都很不容易很不甘心。但也不能扭转，只能寄希望于下一个赛季。</p><blockquote><p>“我们的英雄明年一定要能打大弹丸”</p><p>“明年的工程取弹和上岛要快一些”</p></blockquote><p>在人生的道路上,谁都会遇到困难和挫折,就看你能不能战胜它。战胜了,你就是英雄,就是生活的强者。</p><p>不管别人怎样我决定再干一年，因为这一年的没有得到什么成果很不甘心。这就意味着晚一年再考研，和我做出这一相同决定的还有一位，王启东。他在以后起到了关键作用，是他决定招募操作手。张总也帮了很大忙，负责第一代超级电容的研发。胡晓阳、谢钏、段成凯也都没有离开，负责新赛季的机械设计。有老队员的引导，相比于去年有了很大的进步，起码有了传承和实战的经验。</p><p>从北京观看比赛感触很大，被强队的实力震撼到了。尤其是哈工大，英雄打的又快又准，步兵移动速度很快。和哈工大的交流也学到了很多。</p><p><img src="https://s2.ax1x.com/2019/07/09/Z6NmHU.jpg" alt="混战"></p><p>回学校后准备期末考试，暑假之后，新赛季马上开始了。有了第一年的经验之后，我们做事不再磨磨蹭蹭，进行了赛季规划，确定了人手，明确了每辆车该有的功能以及指标。赛季之初我们的设想还是很丰满的，完全是强队的配置。</p><p>随着时间流逝问题暴露出来，每辆车的进度节点均完不成。面对如此现实，我们讨论决定必须要完成每辆车的基本功能，能跑能打，追求稳定。</p><p>就这样一天天度过，经常会遇到车疯转，烧板子、烧电机，这个时候会很郁闷。心疼，毕竟损失的都是钱。有一次哨兵云台上电后疯狂旋转，当时还没有装上MiniPC，摄像头的线连着我笔记本电脑转了几圈后，扯断了。幸亏我电脑没事只是线断了。步兵跑几圈后开始抽风，不受控制高速自旋。这如果是在赛场上发生这些事，一年的努力就又白费了。车固然重要，但是战术也同样重要，所以得在操作手来实验室之前给修好训练。每每发生这些事，搞得人没法睡觉，通宵去修理肝车。</p><p>就像老师说的那样，你们这个队伍最大的问题，就是没有过成功的经验。很多问题不知道如何解决，浪费了很长时间去摸索，造成总体的效率很低。</p><p>我们就如果在黑夜中行进一般，跌跌撞撞，不断前行。</p><p>临出发前一晚上，超级电容还是有问题。负责步兵的两位，一周都没怎么睡觉了，但是依然坚持到了最后一天凌晨，把超级电容搞得差不多稳定了。</p><p>出发去北京，抽签被分到了死亡小组，对手的实力都很强。队员们都很慌，觉得又会像去年一样出不了小组线。操作手们并没有表示什么。</p><p>和去年一样，晚上赶着给车做保护。白天不能闲着，得需要我们抬着机器人往返于备赛区和检录区、拍照区、测试区等等，进行一系列的预检录、定妆照等活动。资源岛测试要去抢名额。</p><p>正式比赛前一晚上，英雄车换了根线之后开始不正常。大拨弹盘疯转，云台也抖动。问题出现的很突然也很诡异。不知道哪里出了问题，仅仅是换了根线，就造成如此之大的影响。那一晚上我陪着候军辉，还有唐亚坤，一晚上没有合眼去寻找问题试图解决。</p><p>难道是摩擦轮供电有问题？更改供电方式也无济于事。但是其他地方也没有动过，仅仅是换了一根导线，这问题出现的如此紧急，如此棘手难以解决。一晚上也没有找到原因，车的线倒是来回接了好几次。</p><p>第二天一早六点去备赛馆里寻求其他队员的帮助。都没有时间吃早饭加上一晚没有睡觉，侯军辉说他头晕。我去买了两瓶可乐和士力架给他缓解一下补充能量，他是要上场抬车的人，可不能晕倒出事故。直到临近检录十分钟越龙学长提议把主控板用屏蔽纸包起来试试。把主控板包住之后果然恢复正常了！简直就是绝处逢生。这一切简直就是上天故意安排的，就是让你安心不了给你弄出点麻烦来，看你能不能解决。</p><p>体验过绝望才知道安逸是多么难得。觉得自己现在特别能抗住压力了，就是被RM给逼的。</p><p>英雄车这才恢复过来，虽然出现了几次超热量的情况不过影响不大。</p><p>一年的努力还是有结果的，操作手的战术以及依靠着稳定的车辆再配合哨兵的火力输出，打败了北科，北工等传统强校，成功出线。</p><p>打败北工之后当时的兴奋难以表达，终于拿到了深圳总决赛的入场券！之后准备接下来的比赛，紧接着是老对手哈工大。我们打的防守战很有成效，守住了哈工大一波又一波的进攻并且击杀若干，偷家对其造成基地伤害。但是由于那天打了四局比赛，步兵车最终承受不住磨损，有一辆云台脱落，很遗憾直接输给了哈工大。哈工大最终是亚军，东大当之无愧拿下了冠军。</p><p>至此我们已经打完了所有比赛，备战八月份国际总决赛。</p><blockquote><p>未完待续…</p></blockquote><p><img src="https://s2.ax1x.com/2019/07/09/Z6tRpR.md.jpg" alt="IMG_2961.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大多数时候，都在思考自己该走向何方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/09/5d24ac9342dc284698.jpg&quot; alt=&quot;900137ef1538035970503310600.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RoboMaster" scheme="https://hacnix.github.io/categories/RoboMaster/"/>
    
    
      <category term="RoboMaster" scheme="https://hacnix.github.io/tags/RoboMaster/"/>
    
  </entry>
  
  <entry>
    <title>分享一下自己喜欢的几首歌</title>
    <link href="https://hacnix.github.io/2019/07/09/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E5%87%A0%E9%A6%96%E6%AD%8C/"/>
    <id>https://hacnix.github.io/2019/07/09/分享一下自己喜欢的几首歌/</id>
    <published>2019-07-09T11:27:45.000Z</published>
    <updated>2019-07-09T12:16:12.512Z</updated>
    
    <content type="html"><![CDATA[<p>在这里分享几首自己喜欢的音乐，哈哈哈。</p><p>轻音乐居多，因为我很享受这种旋律。</p><p><img src="https://i.loli.net/2019/07/09/5d248246511a533544.jpg" alt="Ok7s-hpB81eoFrwyerQZow%3D%3D%2F3427177779460051.jpg"></p><a id="more"></a><h1 id="For-When-You-Are-Alone-Xeuphoria-For-When-You-Are-Alone"><a href="#For-When-You-Are-Alone-Xeuphoria-For-When-You-Are-Alone" class="headerlink" title="For When You Are Alone - Xeuphoria - For When You Are Alone"></a><a href="http://music.163.com/#/m/song?id=421148106" target="_blank" rel="noopener">For When You Are Alone</a> - Xeuphoria - For When You Are Alone</h1><p>从童年起，我便独自一人，照顾着历代的星辰。</p><p>感觉琴键是在心上敲击，乐声仿佛自天际传来，飘向更远的地方。这首曲子仿佛是作者给孤独者的独奏。相当好听的一首钢琴曲。</p><p><img src="https://i.loli.net/2019/07/09/5d247d9e4b74511874.jpg" alt="3393092898287339.jpg"></p><h1 id="Death-C418-Minecraft-Volume-Alpha-游戏《我的世界》原声带-第1卷"><a href="#Death-C418-Minecraft-Volume-Alpha-游戏《我的世界》原声带-第1卷" class="headerlink" title="Death-C418-Minecraft - Volume Alpha (游戏《我的世界》原声带 第1卷)"></a><a href="http://music.163.com/#/m/song?id=4010190" target="_blank" rel="noopener">Death-C418-Minecraft</a> - Volume Alpha (游戏《我的世界》原声带 第1卷)</h1><p>这是Mniecraft的背景音乐吧，里面有拾取种子和杀鸡的声音，画面感好强23333。</p><p>steve先淌过了水，然后走在草地上，听见了鸡的叫声，接着被steve杀死了，然后steve取走了鸡肉，继续一片祥和。</p><p><img src="https://i.loli.net/2019/07/09/5d247c9d878cd87796.gif" alt="efe0aae3f7f84a9dbf062ccd6b3c08e0f92bab75892fc-kRC27J_fw658.gif"></p><h1 id="What-I-Feel-When-I-See-Her-Xeuphoria-What-I-Feel-When-I-See-Her"><a href="#What-I-Feel-When-I-See-Her-Xeuphoria-What-I-Feel-When-I-See-Her" class="headerlink" title="What I Feel When I See Her - Xeuphoria - What I Feel When I See Her"></a><a href="http://music.163.com/#/m/song?id=437245125" target="_blank" rel="noopener">What I Feel When I See Her</a> - Xeuphoria - What I Feel When I See Her</h1><p>What I Feel When I See Her.</p><p>She was as lovely as an angel. </p><p>I didn’t dare to look her in the eye, for at that instant it seemed as if she could run her eyes inoto mymind.</p><p>依然是Xeuphoria的音乐。调调有些低沉、安静。</p><p>前段轻柔沉醉于初次遇见的美好之中，而后部分沉重，像是在寻找。</p><p>似乎是在询问，我还能再见到她吗？</p><p><img src="https://i.loli.net/2019/07/09/5d248246511a533544.jpg" alt="Ok7s-hpB81eoFrwyerQZow%3D%3D%2F3427177779460051.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这里分享几首自己喜欢的音乐，哈哈哈。&lt;/p&gt;
&lt;p&gt;轻音乐居多，因为我很享受这种旋律。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/09/5d248246511a533544.jpg&quot; alt=&quot;Ok7s-hpB81eoFrwyerQZow%3D%3D%2F3427177779460051.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈碎语" scheme="https://hacnix.github.io/categories/%E6%9D%82%E8%B0%88%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="分享" scheme="https://hacnix.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="音乐" scheme="https://hacnix.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>用hexo+NexT搭建个人博客</title>
    <link href="https://hacnix.github.io/2019/07/09/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAhexo-next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2/"/>
    <id>https://hacnix.github.io/2019/07/09/从零搭建hexo-next主题博客/</id>
    <published>2019-07-09T05:52:11.000Z</published>
    <updated>2019-07-09T07:27:31.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/09/5d243e98593e716101.png" alt="next.png"></p><p>本文主要讲述从零开始搭建个人博客的过程，以及给next主题安装插件时踩过的坑。</p><a id="more"></a><h1 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h1><p>要想使用Gitpage，注册一个github账号是必须的了。在这里注册：<a href="https://github.com" target="_blank" rel="noopener">Github</a>。</p><h1 id="新建一个项目"><a href="#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h1><p>使用注册的账号登陆，在<a href="https://github.com/new" target="_blank" rel="noopener">这里</a>新建一个项目。</p><p>项目的名称要注意，必须是 <strong>username.github.io</strong></p><p><img src="https://i.loli.net/2019/07/09/5d2441675498b95122.png" alt="1218612-6b239b4d8f615b1f.png"></p><h1 id="使用Gitpage"><a href="#使用Gitpage" class="headerlink" title="使用Gitpage"></a>使用Gitpage</h1><p>新建成功之后在项目首页，点击 Settings-&gt;GitHub Pages</p><p><img src="https://i.loli.net/2019/07/09/5d24414852e1741520.png" alt="shiyong.png"></p><p>此时已经有个一个相当于个人网站的东西，图中绿色部分的地址点击即可访问。</p><h1 id="把项目克隆到本地机器"><a href="#把项目克隆到本地机器" class="headerlink" title="把项目克隆到本地机器"></a>把项目克隆到本地机器</h1><p>Git的使用方法及教程可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的个人网站</a></p><p>主要用到以下这几个命令，就足够了。网站里都有详细的讲解。</p><ul><li>git push </li><li>git add</li><li>git commit</li><li>…</li></ul><h1 id="安装hexo主题"><a href="#安装hexo主题" class="headerlink" title="安装hexo主题"></a>安装hexo主题</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。</p><p>大家可以进入<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序:</p><ul><li>Git</li><li>Node.js(Should be at least nodejs 6.9)</li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>否则的话，请参考安装 Node.js的方法。</p><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><blockquote><p>安装 Node.js 的最佳方式是使用 nvm。</p></blockquote><p>cURL:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>或Wget:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$wget</span> -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。<br>另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。</p><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h1 id="更换hexo主题为NexT"><a href="#更换hexo主题为NexT" class="headerlink" title="更换hexo主题为NexT"></a>更换hexo主题为NexT</h1><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 </p><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p> 与所有 Hexo 主题启用的模式一样。 当克隆/下载完成后，打开站点配置文件(blog_path/_config.yml),找到”theme”字段，并将其值更改为”next”。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p><h2 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h2><p>主题设定请参考<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings" target="_blank" rel="noopener">这里</a>。</p><h1 id="给NexT安装插件"><a href="#给NexT安装插件" class="headerlink" title="给NexT安装插件"></a>给NexT安装插件</h1><p>这是一个不断踩坑的过程。</p><ul><li>配置阅读次数</li></ul><p>启用不蒜子统计，仅限于文章页面显示阅读书，在首页不显示。</p><p>修改主题的_config.yml对应的部分为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="comment"># 增加不算子访问数量统计</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  site_uv: <span class="literal">true</span></span><br><span class="line">  site_uv_header: &lt;i class=<span class="string">"fa fa-user"</span>&gt;&lt;/i&gt; 访问人数</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  site_pv: <span class="literal">true</span></span><br><span class="line">  site_pv_header: &lt;i class=<span class="string">"fa fa-eye"</span>&gt;&lt;/i&gt; 访问总量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  page_pv: <span class="literal">true</span></span><br><span class="line">  page_pv_header: &lt;i class=<span class="string">"fa fa-file-o"</span>&gt;&lt;/i&gt; 浏览</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure></p><p>坑：不显示次数</p><p>解决方法：</p><p>找到主题路径 下文件</p><p><code>/theme/next/layout/_third-party/analytics/busuanzi-counter.swig</code></p><p>讲引入的js改为</p><p><code>https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</code></p><p>是由于不蒜子域名过期造成的。</p><ul><li>启用评论</li></ul><p>目前还没有解决，后续跟上=.=。</p><p><img src="https://i.loli.net/2019/07/09/5d244122450d155479.jpg" alt="avatar.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/07/09/5d243e98593e716101.png&quot; alt=&quot;next.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述从零开始搭建个人博客的过程，以及给next主题安装插件时踩过的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://hacnix.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://hacnix.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://hacnix.github.io/tags/next/"/>
    
  </entry>
  
</feed>
